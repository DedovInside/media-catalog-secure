name: Security - SAST & Secrets

# C5: Правильные триггеры - только релевантные изменения
on:
  workflow_dispatch:  # Ручной запуск для тестирования
  push:
    paths:
      - "**/*.py"                               # Python код
      - "**/*.yml"                             # YAML конфигурация  
      - "**/*.yaml"                            # YAML конфигурация
      - "**/*.toml"                            # TOML конфигурация
      - "**/*.json"                            # JSON файлы
      - "security/semgrep/**"                  # Semgrep правила
      - "security/.gitleaks.toml"              # Gitleaks конфигурация
      - ".github/workflows/ci-sast-secrets.yml" # Сам workflow

# C5: Минимальные права безопасности
permissions:
  contents: read
  security-events: write  # Для SARIF upload в GitHub Security (опционально)

# C5: Предотвращение дублирующих запусков
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  sast_secrets_analysis:
    runs-on: ubuntu-latest
    timeout-minutes: 15  # C5: Разумный таймаут

    steps:
      # Базовая подготовка
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Для Gitleaks анализа истории (опционально)

      # C3: Создаем структуру для артефактов
      - name: Prepare evidence directories
        run: |
          mkdir -p EVIDENCE/P10
          echo "Created evidence directory structure for P10"
          ls -la EVIDENCE/

      # C1: SAST сканирование с Semgrep
      - name: Run Semgrep SAST analysis
        run: |
          echo "Starting Static Application Security Testing (SAST) with Semgrep..."
          
          # Используем фиксированную версию для воспроизводимости
          docker run --rm \
            -v $PWD:/src \
            -w /src \
            returntocorp/semgrep:1.45.0 \
            semgrep ci \
              --config=p/ci \
              --config=/src/security/semgrep/rules.yml \
              --sarif \
              --output=/src/EVIDENCE/P10/semgrep.sarif \
              --metrics=off \
              --verbose || true
          
          echo "Semgrep SAST analysis completed"
          echo "SARIF report size: $(du -h EVIDENCE/P10/semgrep.sarif | cut -f1)"
          
          # Краткая валидация SARIF отчета
          if [ -f "EVIDENCE/P10/semgrep.sarif" ]; then
            echo "SARIF report validation:"
            if jq -e '.runs[0].results' EVIDENCE/P10/semgrep.sarif > /dev/null 2>&1; then
              findings_count=$(jq '.runs[0].results | length' EVIDENCE/P10/semgrep.sarif)
              echo "Found $findings_count SAST findings"
              
              # Показываем статистику по severity
              if [ "$findings_count" -gt 0 ]; then
                echo "Findings by severity:"
                jq -r '.runs[0].results[] | .level // "unknown"' EVIDENCE/P10/semgrep.sarif | sort | uniq -c
              fi
            else
              echo "SARIF report format validation failed"
            fi
          else
            echo "SARIF report not generated"
            exit 1
          fi

      # C2: Secrets сканирование с Gitleaks
      - name: Run Gitleaks secrets detection
        run: |
          echo "Starting secrets detection with Gitleaks..."
          
          # Используем фиксированную версию для воспроизводимости
          docker run --rm \
            -v $PWD:/repo \
            -w /repo \
            zricethezav/gitleaks:v8.18.0 \
            detect \
              --no-banner \
              --config=/repo/security/.gitleaks.toml \
              --source=/repo \
              --report-format=json \
              --report-path=/repo/EVIDENCE/P10/gitleaks.json \
              --verbose || true
          
          echo "Gitleaks secrets detection completed"
          echo "Secrets report size: $(du -h EVIDENCE/P10/gitleaks.json | cut -f1)"
          
          # Анализ результатов сканирования секретов
          if [ -f "EVIDENCE/P10/gitleaks.json" ]; then
            echo "Secrets detection results analysis:"
            
            # Проверяем есть ли найденные секреты
            if jq -e '. | length > 0' EVIDENCE/P10/gitleaks.json > /dev/null 2>&1; then
              secrets_count=$(jq '. | length' EVIDENCE/P10/gitleaks.json)
              echo "Found $secrets_count potential secrets!"
              
              # Показываем краткую статистику
              echo "Secrets by type:"
              jq -r '.[].RuleID' EVIDENCE/P10/gitleaks.json | sort | uniq -c | head -10
              
              echo "Files with potential secrets:"
              jq -r '.[].File' EVIDENCE/P10/gitleaks.json | sort | uniq -c | head -5
              
              # ВАЖНО: не выводим сами секреты в логи!
              echo "Please review EVIDENCE/P10/gitleaks.json for detailed findings"
              echo "Consider adding false positives to security/.gitleaks.toml allowlist"
            else
              echo "No secrets detected - excellent security posture!"
            fi
          else
            echo "Gitleaks report not generated"
            exit 1
          fi

      # C3: Создание сводки по результатам анализа
      - name: Generate SAST & Secrets summary
        run: |
          echo "Generating comprehensive security analysis summary..."
          
          # Создаем детальную сводку
          cat > EVIDENCE/P10/sast_summary.md << 'EOF'
          # SAST & Secrets Analysis Summary
          
          **Generated:** $(date -Iseconds)  
          **Commit:** ${{ github.sha }}  
          **Workflow:** ${{ github.run_id }}  
          **SAST Tool:** Semgrep v1.45.0  
          **Secrets Tool:** Gitleaks v8.18.0  
          
          ## SAST Analysis Results (Semgrep)
          
          EOF
          
          # Анализируем SAST результаты
          if [ -f "EVIDENCE/P10/semgrep.sarif" ]; then
            findings_count=$(jq '.runs[0].results | length' EVIDENCE/P10/semgrep.sarif 2>/dev/null || echo "0")
            
            echo "### Findings Summary" >> EVIDENCE/P10/sast_summary.md
            echo "" >> EVIDENCE/P10/sast_summary.md
            echo "- **Total findings**: $findings_count" >> EVIDENCE/P10/sast_summary.md
            
            if [ "$findings_count" -gt 0 ]; then
              # Статистика по severity levels
              echo "- **By severity**:" >> EVIDENCE/P10/sast_summary.md
              jq -r '.runs[0].results[] | .level // "unknown"' EVIDENCE/P10/semgrep.sarif | sort | uniq -c | while read count level; do
                echo "  - $level: $count" >> EVIDENCE/P10/sast_summary.md
              done
              
              # Топ правил с находками
              echo "" >> EVIDENCE/P10/sast_summary.md
              echo "### Top Security Rules Triggered" >> EVIDENCE/P10/sast_summary.md
              echo "" >> EVIDENCE/P10/sast_summary.md
              jq -r '.runs[0].results[] | .ruleId' EVIDENCE/P10/semgrep.sarif | sort | uniq -c | sort -nr | head -5 | while read count rule; do
                echo "- **$rule**: $count occurrences" >> EVIDENCE/P10/sast_summary.md
              done
              
              # Выводим в консоль
              echo "SAST Findings: $findings_count total"
              echo "By severity:"
              jq -r '.runs[0].results[] | .level // "unknown"' EVIDENCE/P10/semgrep.sarif | sort | uniq -c
            else
              echo "No SAST findings detected" >> EVIDENCE/P10/sast_summary.md
              echo "SAST: No security issues found"
            fi
          fi
          
          # Анализируем Secrets результаты
          cat >> EVIDENCE/P10/sast_summary.md << 'EOF'
          
          ## Secrets Detection Results (Gitleaks)
          
          EOF
          
          if [ -f "EVIDENCE/P10/gitleaks.json" ]; then
            secrets_count=$(jq '. | length' EVIDENCE/P10/gitleaks.json 2>/dev/null || echo "0")
            
            echo "### Secrets Summary" >> EVIDENCE/P10/sast_summary.md
            echo "" >> EVIDENCE/P10/sast_summary.md
            echo "- **Total potential secrets**: $secrets_count" >> EVIDENCE/P10/sast_summary.md
            
            if [ "$secrets_count" -gt 0 ]; then
              # Статистика по типам секретов
              echo "- **By secret type**:" >> EVIDENCE/P10/sast_summary.md
              jq -r '.[].RuleID' EVIDENCE/P10/gitleaks.json | sort | uniq -c | head -10 | while read count rule; do
                echo "  - $rule: $count" >> EVIDENCE/P10/sast_summary.md
              done
              
              # Файлы с потенциальными секретами
              echo "" >> EVIDENCE/P10/sast_summary.md
              echo "### Files with Potential Secrets" >> EVIDENCE/P10/sast_summary.md
              echo "" >> EVIDENCE/P10/sast_summary.md
              jq -r '.[].File' EVIDENCE/P10/gitleaks.json | sort | uniq -c | head -5 | while read count file; do
                echo "- **$file**: $count findings" >> EVIDENCE/P10/sast_summary.md
              done
              
              echo "Secrets: $secrets_count potential secrets found"
            else
              echo "No potential secrets detected" >> EVIDENCE/P10/sast_summary.md
              echo "Secrets: No credentials found in code"
            fi
          fi
          
          # Добавляем рекомендации и следующие шаги
          cat >> EVIDENCE/P10/sast_summary.md << 'EOF'
          
          ## Security Analysis Configuration
          
          ### SAST Rules Used
          - **Standard ruleset**: `p/ci` (Semgrep community rules for CI)
          - **Custom rules**: `security/semgrep/rules.yml` (Media Catalog specific)
          - **Focus areas**: SQL injection, XSS, hardcoded credentials, insecure randomness
          
          ### Secrets Detection Rules  
          - **Base configuration**: Gitleaks default rules
          - **Custom allowlist**: `security/.gitleaks.toml`
          - **Excluded paths**: EVIDENCE/, tests/, documentation examples
          
          ## Next Steps
          
          1. **Review all ERROR level SAST findings** - immediate security risk
          2. **Investigate potential secrets** - verify if real credentials leaked
          3. **Update allowlists** - add false positives to configuration
          4. **Create security issues** - track remediation of real findings
          5. **Update security policies** - document acceptable risk thresholds
          
          ## Files Generated
          
          - `EVIDENCE/P10/semgrep.sarif` - SAST findings in SARIF format
          - `EVIDENCE/P10/gitleaks.json` - Secrets detection results
          - `EVIDENCE/P10/sast_summary.md` - This human-readable summary
          
          ## Integration Points
          
          - **CI/CD**: Automated security scanning on every push
          - **GitHub Security**: SARIF results can be uploaded to Security tab
          - **Developer Workflow**: Pre-commit hooks complement CI scanning
          - **Compliance**: Security reports for DS documentation
          
          EOF
          
          echo "Security analysis summary generated successfully"

      # C3: Сохранение метаданных сканирования 
      - name: Save security scan metadata
        run: |
          echo "Saving security scan metadata for traceability..."
          
          cat > EVIDENCE/P10/scan_metadata.json << EOF
          {
            "scan_date": "$(date -Iseconds)",
            "commit_sha": "${{ github.sha }}",
            "commit_ref": "${{ github.ref_name }}",
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_url": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}",
            "tools": {
              "sast_scanner": "returntocorp/semgrep:1.45.0",
              "secrets_scanner": "zricethezav/gitleaks:v8.18.0",
              "sast_config": ["p/ci", "security/semgrep/rules.yml"],
              "secrets_config": "security/.gitleaks.toml"
            },
            "analysis_scope": {
              "file_types": ["python", "yaml", "json", "toml"],
              "custom_rules": 5,
              "secrets_allowlist_entries": 10
            },
            "repository": "${{ github.repository }}",
            "actor": "${{ github.actor }}"
          }
          EOF

      # C3: Загрузка всех артефактов
      - name: Upload SAST & Secrets evidence artifacts
        if: always()  # Загружаем даже при наличии findings
        uses: actions/upload-artifact@v4
        with:
          name: P10_SAST_Secrets_Evidence
          path: EVIDENCE/P10/
          retention-days: 90  # Долгосрочное хранение для compliance

      # C4: Анализ результатов и рекомендации по findings
      - name: Analyze security findings and provide recommendations  
        if: always()
        run: |
          echo "Security Analysis Summary"
          echo "============================"
          
          # Анализируем SAST результаты
          if [ -f "EVIDENCE/P10/semgrep.sarif" ]; then
            sast_findings=$(jq '.runs[0].results | length' EVIDENCE/P10/semgrep.sarif 2>/dev/null || echo "0")
            echo "SAST Findings: $sast_findings total"
            
            if [ "$sast_findings" -gt 0 ]; then
              # Критические находки
              error_count=$(jq '.runs[0].results[] | select(.level == "error") | .ruleId' EVIDENCE/P10/semgrep.sarif 2>/dev/null | wc -l || echo "0")
              warning_count=$(jq '.runs[0].results[] | select(.level == "warning") | .ruleId' EVIDENCE/P10/semgrep.sarif 2>/dev/null | wc -l || echo "0")
              
              echo "ERROR level: $error_count (immediate action required)"
              echo "WARNING level: $warning_count (review recommended)"
              
              if [ "$error_count" -gt 0 ]; then
                echo ""
                echo "Critical Security Issues Found!"
                echo "ERROR level findings require immediate attention:"
                jq -r '.runs[0].results[] | select(.level == "error") | "- \(.ruleId): \(.message)"' EVIDENCE/P10/semgrep.sarif | head -5
              fi
            else
              echo "No SAST security issues detected"
            fi
          fi
          
          # Анализируем Secrets результаты
          if [ -f "EVIDENCE/P10/gitleaks.json" ]; then
            secrets_count=$(jq '. | length' EVIDENCE/P10/gitleaks.json 2>/dev/null || echo "0")
            echo "Secrets Detection: $secrets_count potential secrets"
            
            if [ "$secrets_count" -gt 0 ]; then
              echo "Potential secrets detected!"
              echo "Secret types found:"
              jq -r '.[].RuleID' EVIDENCE/P10/gitleaks.json | sort | uniq -c | head -5
              echo ""
              echo "IMPORTANT: Review each finding to determine if real credentials"
              echo "Add false positives to security/.gitleaks.toml allowlist"
            else
              echo "No secrets detected in repository"
            fi
          fi
          
          # Общие рекомендации
          echo ""
          echo "Recommended Actions:"
          echo "1. Review detailed reports: EVIDENCE/P10/sast_summary.md"
          echo "2. Download artifacts: P10_SAST_Secrets_Evidence.zip"
          echo "3. Investigate ERROR level SAST findings first"
          echo "4. Verify any potential secrets are not real credentials"
          echo "5. Update allowlists for confirmed false positives"
          echo "6. Create security issues for tracking remediation"
          echo ""
          echo "Evidence Files Generated:"
          echo "- EVIDENCE/P10/semgrep.sarif (SAST findings)"
          echo "- EVIDENCE/P10/gitleaks.json (secrets detection)"
          echo "- EVIDENCE/P10/sast_summary.md (human-readable analysis)"
          echo "- EVIDENCE/P10/scan_metadata.json (traceability data)"
          echo ""
          echo "Workflow run: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"

      # C5: Опциональная интеграция с GitHub Security (для продвинутого уровня)
      - name: Upload SARIF to GitHub Security (optional)
        if: always() && github.ref == 'refs/heads/main'
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: EVIDENCE/P10/semgrep.sarif
        continue-on-error: true  # Не блокируем workflow если загрузка не удалась